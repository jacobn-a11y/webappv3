generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ─── Auth & Tenancy ──────────────────────────────────────────────────────────

model Organization {
  id               String    @id @default(cuid())
  name             String
  workosOrgId      String?   @unique
  stripeCustomerId String?   @unique
  plan             Plan      @default(FREE_TRIAL)
  trialEndsAt      DateTime?
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt

  users        User[]
  accounts     Account[]
  calls        Call[]
  stories      Story[]
  landingPages LandingPage[]
  orgSettings  OrgSettings?
  orgAISettings       OrgAISettings?
  orgAIRoleDefaults   OrgAIRoleDefault[]
  aiProviderConfigs   AIProviderConfig[]
  aiUsageRecords      AIUsageRecord[]
  aiUsageLimits       AIUsageLimit[]
  aiUsageNotifications AIUsageNotification[]
  userAIBalances      UserAIBalance[]

  @@map("organizations")
}

enum Plan {
  FREE_TRIAL
  STARTER
  PROFESSIONAL
  ENTERPRISE
}

model User {
  id             String   @id @default(cuid())
  email          String   @unique
  name           String?
  workosUserId   String?  @unique
  organizationId String
  role           UserRole @default(MEMBER)
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  organization      Organization       @relation(fields: [organizationId], references: [id])
  landingPages      LandingPage[]      @relation("CreatedBy")
  landingPageEdits  LandingPageEdit[]
  permissions       UserPermission[]
  accountAccess     UserAccountAccess[]
  aiUsageRecords    AIUsageRecord[]
  aiUsageLimits     AIUsageLimit[]
  aiUsageNotifications AIUsageNotification[]
  aiAccess          UserAIAccess?
  aiBalance         UserAIBalance?

  @@index([organizationId])
  @@map("users")
}

enum UserRole {
  OWNER
  ADMIN
  MEMBER
  VIEWER
}

// ─── CRM Entities ────────────────────────────────────────────────────────────

model Account {
  id              String   @id @default(cuid())
  organizationId  String
  name            String
  normalizedName  String   // lowercase, stripped of Inc/Corp/LLC suffixes
  domain          String?  // primary email domain (e.g., "bigtech.com")
  salesforceId    String?
  hubspotId       String?
  mergeAccountId  String?
  industry        String?
  employeeCount   Int?
  annualRevenue   Float?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  organization    Organization     @relation(fields: [organizationId], references: [id])
  contacts        Contact[]
  calls           Call[]
  salesforceEvents SalesforceEvent[]
  stories         Story[]
  domainAliases   AccountDomain[]
  userAccess      UserAccountAccess[]

  @@unique([organizationId, domain])
  @@unique([organizationId, salesforceId])
  @@index([organizationId, normalizedName])
  @@map("accounts")
}

model AccountDomain {
  id        String @id @default(cuid())
  accountId String
  domain    String // additional email domains for the same account

  account Account @relation(fields: [accountId], references: [id], onDelete: Cascade)

  @@unique([accountId, domain])
  @@index([domain])
  @@map("account_domains")
}

model Contact {
  id             String   @id @default(cuid())
  accountId      String
  email          String
  emailDomain    String   // extracted domain portion
  name           String?
  title          String?
  phone          String?
  salesforceId   String?
  hubspotId      String?
  mergeContactId String?
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  account        Account           @relation(fields: [accountId], references: [id])
  callParticipants CallParticipant[]

  @@unique([accountId, email])
  @@index([emailDomain])
  @@map("contacts")
}

// ─── Calls & Transcripts ─────────────────────────────────────────────────────

model Call {
  id               String       @id @default(cuid())
  organizationId   String
  accountId        String?      // resolved via Entity Resolution; null until matched
  title            String?
  provider         CallProvider
  mergeRecordingId String?      @unique
  externalId       String?      // provider-native ID
  recordingUrl     String?
  duration         Int?         // seconds
  occurredAt       DateTime
  createdAt        DateTime     @default(now())
  updatedAt        DateTime     @updatedAt

  organization Organization      @relation(fields: [organizationId], references: [id])
  account      Account?          @relation(fields: [accountId], references: [id])
  transcript   Transcript?
  participants CallParticipant[]
  tags         CallTag[]

  @@index([organizationId, accountId])
  @@index([organizationId, occurredAt])
  @@map("calls")
}

enum CallProvider {
  GONG
  CHORUS
  ZOOM
  GOOGLE_MEET
  TEAMS
  FIREFLIES
  DIALPAD
  AIRCALL
  RINGCENTRAL
  SALESLOFT
  OUTREACH
  OTHER
}

model CallParticipant {
  id        String  @id @default(cuid())
  callId    String
  contactId String?
  email     String?
  name      String?
  isHost    Boolean @default(false)

  call    Call     @relation(fields: [callId], references: [id], onDelete: Cascade)
  contact Contact? @relation(fields: [contactId], references: [id])

  @@index([callId])
  @@index([email])
  @@map("call_participants")
}

model Transcript {
  id         String   @id @default(cuid())
  callId     String   @unique
  fullText   String   // complete transcript text
  language   String   @default("en")
  wordCount  Int
  createdAt  DateTime @default(now())

  call   Call              @relation(fields: [callId], references: [id], onDelete: Cascade)
  chunks TranscriptChunk[]

  @@map("transcripts")
}

model TranscriptChunk {
  id           String   @id @default(cuid())
  transcriptId String
  chunkIndex   Int
  text         String
  speaker      String?
  startMs      Int?     // timestamp offset in milliseconds
  endMs        Int?
  embeddingId  String?  // Pinecone vector ID
  createdAt    DateTime @default(now())

  transcript Transcript @relation(fields: [transcriptId], references: [id], onDelete: Cascade)
  tags       ChunkTag[]

  @@unique([transcriptId, chunkIndex])
  @@map("transcript_chunks")
}

// ─── Taxonomy Tags ───────────────────────────────────────────────────────────

model CallTag {
  id         String        @id @default(cuid())
  callId     String
  funnelStage FunnelStage
  topic      String        // specific topic from taxonomy
  confidence Float         // LLM confidence 0.0-1.0
  createdAt  DateTime      @default(now())

  call Call @relation(fields: [callId], references: [id], onDelete: Cascade)

  @@unique([callId, funnelStage, topic])
  @@index([funnelStage])
  @@map("call_tags")
}

model ChunkTag {
  id         String      @id @default(cuid())
  chunkId    String
  funnelStage FunnelStage
  topic      String
  confidence Float
  createdAt  DateTime    @default(now())

  chunk TranscriptChunk @relation(fields: [chunkId], references: [id], onDelete: Cascade)

  @@unique([chunkId, funnelStage, topic])
  @@map("chunk_tags")
}

enum FunnelStage {
  TOFU       // Top of Funnel
  MOFU       // Mid-Funnel
  BOFU       // Bottom of Funnel
  POST_SALE
  INTERNAL
  VERTICAL   // Vertical/Segment cuts
}

// ─── CRM Events ──────────────────────────────────────────────────────────────

model SalesforceEvent {
  id            String          @id @default(cuid())
  accountId     String
  eventType     SalesforceEventType
  stageName     String?         // e.g., "Closed Won", "Closed Lost"
  opportunityId String?
  amount        Float?
  closeDate     DateTime?
  description   String?
  rawPayload    Json?
  createdAt     DateTime        @default(now())

  account Account @relation(fields: [accountId], references: [id])

  @@index([accountId, eventType])
  @@map("salesforce_events")
}

enum SalesforceEventType {
  OPPORTUNITY_CREATED
  OPPORTUNITY_STAGE_CHANGE
  CLOSED_WON
  CLOSED_LOST
  CONTACT_CREATED
  LEAD_CONVERTED
  TASK_COMPLETED
  NOTE_ADDED
}

// ─── Generated Stories ───────────────────────────────────────────────────────

model Story {
  id             String      @id @default(cuid())
  organizationId String
  accountId      String
  title          String
  markdownBody   String      // the generated Markdown story
  storyType      StoryType
  funnelStages   FunnelStage[] // which stages this story covers
  filterTags     String[]    // which taxonomy topics were used to filter
  aiProvider     String?     // which AI provider was used (e.g., "openai", "anthropic")
  aiModel        String?     // which model was used (e.g., "gpt-4o", "claude-sonnet-4-20250514")
  generatedById  String?     // user who triggered the generation
  generatedAt    DateTime    @default(now())
  updatedAt      DateTime    @updatedAt

  organization Organization @relation(fields: [organizationId], references: [id])
  account      Account      @relation(fields: [accountId], references: [id])
  quotes       HighValueQuote[]
  landingPages LandingPage[]

  @@index([organizationId, accountId])
  @@index([organizationId, generatedById])
  @@map("stories")
}

enum StoryType {
  FULL_JOURNEY
  ONBOARDING
  ROI_ANALYSIS
  COMPETITIVE_WIN
  EXPANSION
  CUSTOM
}

model HighValueQuote {
  id          String   @id @default(cuid())
  storyId     String
  speaker     String?
  quoteText   String
  context     String?  // surrounding context
  metricType  String?  // e.g., "cost_savings", "time_saved", "revenue"
  metricValue String?  // e.g., "40%", "$2M", "3x"
  callId      String?  // source call
  createdAt   DateTime @default(now())

  story Story @relation(fields: [storyId], references: [id], onDelete: Cascade)

  @@index([storyId])
  @@map("high_value_quotes")
}

// ─── Landing Pages (Publishable Story Pages) ────────────────────────────────

model LandingPage {
  id              String            @id @default(cuid())
  organizationId  String
  storyId         String
  createdById     String
  slug            String            @unique   // URL slug: /s/{slug}
  title           String
  subtitle        String?
  editableBody    String            // rich Markdown edited by the rep
  scrubbedBody    String            // company-name-scrubbed version for public
  heroImageUrl    String?
  calloutBoxes    Json?             // array of {title, body, icon} callout blocks
  totalCallHours  Float             @default(0) // for the "Compiled from X hours" badge
  visibility      PageVisibility    @default(PRIVATE)
  status          PageStatus        @default(DRAFT)
  password        String?           // optional password for SHARED_WITH_LINK pages
  includeCompanyName Boolean        @default(false) // admin-only: named landing page
  noIndex         Boolean           @default(true)
  customCss       String?
  viewCount       Int               @default(0)
  publishedAt     DateTime?
  expiresAt       DateTime?         // optional expiration for shared links
  createdAt       DateTime          @default(now())
  updatedAt       DateTime          @updatedAt

  organization Organization       @relation(fields: [organizationId], references: [id])
  story        Story               @relation(fields: [storyId], references: [id])
  createdBy    User                @relation("CreatedBy", fields: [createdById], references: [id])
  edits        LandingPageEdit[]

  @@index([organizationId, status])
  @@index([slug])
  @@map("landing_pages")
}

enum PageVisibility {
  PRIVATE           // only visible to org members
  SHARED_WITH_LINK  // anyone with the link (optionally password-protected)
}

enum PageStatus {
  DRAFT
  PUBLISHED
  ARCHIVED
}

model LandingPageEdit {
  id            String   @id @default(cuid())
  landingPageId String
  editedById    String
  previousBody  String   // snapshot before this edit
  newBody       String   // snapshot after this edit
  editSummary   String?
  createdAt     DateTime @default(now())

  landingPage LandingPage @relation(fields: [landingPageId], references: [id], onDelete: Cascade)
  editedBy    User        @relation(fields: [editedById], references: [id])

  @@index([landingPageId])
  @@map("landing_page_edits")
}

// ─── Permissions & Org Settings ──────────────────────────────────────────────

model OrgSettings {
  id                        String   @id @default(cuid())
  organizationId            String   @unique
  landingPagesEnabled       Boolean  @default(true)
  defaultPageVisibility     PageVisibility @default(PRIVATE)
  requireApprovalToPublish  Boolean  @default(false)
  allowedPublishers         UserRole[] @default([OWNER, ADMIN]) // roles that can publish
  maxPagesPerUser           Int?     // null = unlimited
  companyNameReplacements   Json?    // custom scrub mappings: {"Acme Corp": "the client"}
  createdAt                 DateTime @default(now())
  updatedAt                 DateTime @updatedAt

  organization Organization @relation(fields: [organizationId], references: [id])

  @@map("org_settings")
}

model UserPermission {
  id             String           @id @default(cuid())
  userId         String
  permission     PermissionType
  grantedById    String?
  createdAt      DateTime         @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, permission])
  @@map("user_permissions")
}

enum PermissionType {
  CREATE_LANDING_PAGE
  PUBLISH_LANDING_PAGE
  PUBLISH_NAMED_LANDING_PAGE  // publish with real company name visible
  EDIT_ANY_LANDING_PAGE
  DELETE_ANY_LANDING_PAGE
  MANAGE_PERMISSIONS
  VIEW_ANALYTICS
  MANAGE_AI_SETTINGS          // configure AI providers, API keys, and usage limits
}

// ─── Account-Scoped Access Control ───────────────────────────────────────────

model UserAccountAccess {
  id             String           @id @default(cuid())
  userId         String
  organizationId String
  scopeType      AccountScopeType
  accountId      String?
  crmReportId    String?
  crmProvider    CRMProvider?
  crmReportName  String?
  cachedAccountIds String[]       @default([])
  lastSyncedAt   DateTime?
  grantedById    String?
  createdAt      DateTime         @default(now())
  updatedAt      DateTime         @updatedAt

  user    User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  account Account? @relation(fields: [accountId], references: [id])

  @@index([userId, organizationId])
  @@index([userId, accountId])
  @@map("user_account_access")
}

enum AccountScopeType {
  ALL_ACCOUNTS
  SINGLE_ACCOUNT
  ACCOUNT_LIST
  CRM_REPORT
}

enum CRMProvider {
  SALESFORCE
  HUBSPOT
}

// ═════════════════════════════════════════════════════════════════════════════
// AI PROVIDER CONFIGURATION, BILLING & USAGE
// ═════════════════════════════════════════════════════════════════════════════

enum AIProviderType {
  OPENAI
  ANTHROPIC
  GOOGLE
}

// ─── Platform-Level AI Configuration ────────────────────────────────────────
// Managed by the platform owner (application developer / SaaS operator).
// These are the AI providers that the platform makes available to all orgs
// by default. Platform owner sets their own API keys and per-model pricing.

model PlatformAIProvider {
  id              String         @id @default(cuid())
  provider        AIProviderType
  encryptedApiKey String         // AES-256-GCM encrypted platform API key
  keyIv           String
  keyAuthTag      String
  isActive        Boolean        @default(true)
  createdAt       DateTime       @default(now())
  updatedAt       DateTime       @updatedAt

  models PlatformModelPricing[]

  @@unique([provider])
  @@map("platform_ai_providers")
}

model PlatformModelPricing {
  id                      String         @id @default(cuid())
  platformProviderId      String
  provider                AIProviderType
  modelId                 String         // e.g., "gpt-4o", "claude-sonnet-4-20250514"
  displayName             String         // e.g., "GPT-4o", "Claude 3.5 Sonnet"
  inputCostPer1kTokens    Float          // cost per 1,000 input tokens (in cents)
  outputCostPer1kTokens   Float          // cost per 1,000 output tokens (in cents)
  isAvailable             Boolean        @default(true)
  sortOrder               Int            @default(0)
  createdAt               DateTime       @default(now())
  updatedAt               DateTime       @updatedAt

  platformProvider PlatformAIProvider @relation(fields: [platformProviderId], references: [id], onDelete: Cascade)

  @@unique([provider, modelId])
  @@map("platform_model_pricing")
}

// ─── Organization AI Settings ───────────────────────────────────────────────
// Account admins configure how their org uses AI. They can either use
// platform-provided AI (billed per token at platform pricing) or bring
// their own API keys.

model OrgAISettings {
  id                       String    @id @default(cuid())
  organizationId           String    @unique
  defaultProvider          String?   // default AI provider name
  defaultModel             String?   // default model name
  // Seat-based limits: multiplied by org user count
  perSeatTokenBudgetPerMonth Int?    // token budget per seat per month
  perSeatStoriesPerMonth   Int?      // stories per seat per month
  // Flat org-wide limits (alternative to seat-based)
  maxStoriesPerMonth       Int?      // total stories per month for the org
  createdAt                DateTime  @default(now())
  updatedAt                DateTime  @updatedAt

  organization Organization @relation(fields: [organizationId], references: [id])

  @@map("org_ai_settings")
}

// NOTE: AI source is resolved per-provider, not globally.
// If the org has configured their own API key for a provider (AIProviderConfig),
// that key is used exclusively for that provider. For providers without a
// custom key, the platform's key is used (and billed at platform pricing).
// This allows orgs to bring their own key for one provider while still
// purchasing access to other providers from the platform.

// ─── Per-Role AI Defaults ───────────────────────────────────────────────────
// Admin can set default AI access rules per role (MEMBER, VIEWER, etc.).
// These serve as the baseline; individual user overrides take precedence.

model OrgAIRoleDefault {
  id                  String           @id @default(cuid())
  organizationId      String
  role                UserRole
  allowedProviders    AIProviderType[] // empty = all available
  allowedModels       String[]         // empty = all available
  maxTokensPerDay     Int?
  maxTokensPerMonth   Int?
  maxStoriesPerMonth  Int?
  maxRequestsPerDay   Int?
  createdAt           DateTime         @default(now())
  updatedAt           DateTime         @updatedAt

  organization Organization @relation(fields: [organizationId], references: [id])

  @@unique([organizationId, role])
  @@map("org_ai_role_defaults")
}

// ─── Per-User AI Access Control ─────────────────────────────────────────────
// Admin can override which providers/models individual users can access.
// Takes precedence over role defaults.

model UserAIAccess {
  id               String           @id @default(cuid())
  organizationId   String
  userId           String
  allowedProviders AIProviderType[] // empty = inherit from role default
  allowedModels    String[]         // empty = inherit from role default
  deniedProviders  AIProviderType[] // explicit denials override allows
  deniedModels     String[]         // explicit denials override allows
  grantedById      String?
  createdAt        DateTime         @default(now())
  updatedAt        DateTime         @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([organizationId, userId])
  @@map("user_ai_access")
}

// ─── Custom Org-Level API Keys ──────────────────────────────────────────────
// When an org chooses AISource=CUSTOM, their admin configures API keys here.
// These are encrypted at rest with AES-256-GCM.

model AIProviderConfig {
  id               String         @id @default(cuid())
  organizationId   String
  provider         AIProviderType
  encryptedApiKey  String
  keyIv            String
  keyAuthTag       String
  displayName      String?
  defaultModel     String?
  embeddingModel   String?
  isDefault        Boolean        @default(false)
  isActive         Boolean        @default(true)
  createdAt        DateTime       @default(now())
  updatedAt        DateTime       @updatedAt

  organization Organization @relation(fields: [organizationId], references: [id])

  @@unique([organizationId, provider])
  @@map("ai_provider_configs")
}

// ─── Per-User Prepaid Balance ───────────────────────────────────────────────
// When using platform AI, each user has a prepaid balance that gets drawn
// down as they use AI features. Admins top up balances for their users.

model UserAIBalance {
  id               String   @id @default(cuid())
  organizationId   String
  userId           String
  balanceCents     Int      @default(0) // balance in cents (USD)
  lifetimeSpentCents Int    @default(0) // total spent over all time
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  user         User         @relation(fields: [userId], references: [id])
  organization Organization @relation(fields: [organizationId], references: [id])
  transactions UserAITransaction[]

  @@unique([organizationId, userId])
  @@map("user_ai_balances")
}

model UserAITransaction {
  id             String            @id @default(cuid())
  balanceId      String
  type           AITransactionType
  amountCents    Int               // always positive; direction determined by type
  description    String
  usageRecordId  String?           // links to AIUsageRecord that caused a DEBIT
  createdAt      DateTime          @default(now())

  balance UserAIBalance @relation(fields: [balanceId], references: [id])

  @@index([balanceId, createdAt])
  @@map("user_ai_transactions")
}

enum AITransactionType {
  CREDIT    // balance top-up
  DEBIT     // usage charge
  REFUND    // reversed charge
}

// ─── AI Usage Tracking & Limits ─────────────────────────────────────────────

enum AIOperation {
  STORY_GENERATION
  QUOTE_EXTRACTION
  TRANSCRIPT_TAGGING
  RAG_QUERY
  EMBEDDING
}

model AIUsageRecord {
  id               String       @id @default(cuid())
  organizationId   String
  userId           String
  provider         String       // e.g., "openai", "anthropic"
  model            String       // e.g., "gpt-4o", "claude-sonnet-4-20250514"
  operation        AIOperation
  inputTokens      Int
  outputTokens     Int
  totalTokens      Int
  costCents        Float        @default(0) // computed cost in cents
  createdAt        DateTime     @default(now())

  organization Organization @relation(fields: [organizationId], references: [id])
  user         User         @relation(fields: [userId], references: [id])

  @@index([organizationId, userId, createdAt])
  @@index([organizationId, createdAt])
  @@map("ai_usage_records")
}

model AIUsageLimit {
  id                   String   @id @default(cuid())
  organizationId       String
  userId               String?  // null = org-wide default limit
  maxTokensPerDay      Int?
  maxTokensPerMonth    Int?
  maxRequestsPerDay    Int?
  maxRequestsPerMonth  Int?
  maxStoriesPerMonth   Int?     // alternative: cap on case studies generated
  warningThresholdPct  Int      @default(80)
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt

  organization Organization @relation(fields: [organizationId], references: [id])
  user         User?        @relation(fields: [userId], references: [id])

  @@unique([organizationId, userId])
  @@map("ai_usage_limits")
}

model AIUsageNotification {
  id               String   @id @default(cuid())
  organizationId   String
  userId           String
  limitType        String   // "daily_tokens", "monthly_tokens", "monthly_stories", etc.
  thresholdPct     Int      // e.g., 80, 90, 100
  currentUsage     Int
  limitValue       Int
  message          String
  acknowledged     Boolean  @default(false)
  createdAt        DateTime @default(now())

  organization Organization @relation(fields: [organizationId], references: [id])
  user         User         @relation(fields: [userId], references: [id])

  @@index([userId, acknowledged, createdAt])
  @@map("ai_usage_notifications")
}
